{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/07/05/hello-world/"},{"title":"学习日志","text":"2022-07-07 学习数据结构-树-二叉树 修改博客 通过上传图片至Github仓库，通过网络连接调用 ![照片名称](https://birdplus.github.io/img/postimg/XXX.png) ![照片名称][1] [1]:https://birdplus.github.io/img/postimg/XXX.png","link":"/2022/07/07/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6/"},{"title":"树","text":"树的定义由n个节点构成的有限集合 树的性质 树种有一个称为“根（root）”的特殊结点，用r表示： 其余结点可分为m个互不相交的有限集T1，T2…其中每一个集合又是一颗独立的书，成为原来树的“子树（subtree）” 子树不相交 N个节点的树有N-1条边 树的基本术语 结点的度：结点的子树个数 树的度：树种所有结点最大的度 叶结点：度为0的结点 父结点：为子结点的根结点 子结点： 兄弟结点： 祖先结点： 子孙结点： 路径和路径长度：结点个数 结点的层次：规定根结点在1层，其他结点层数为其父结点层次加一 树的深度：树中所有结点的最大层次 树的表示儿子兄弟表示法：二叉树（度为2的树） 树的概念引出 有序化 定义顺序进行查找 二叉树性质二叉树的子树有左右之分 特殊二叉树 斜二叉树 完美二叉树/满二叉树 完全二叉树：编号从上至下左至右顺序跟完美二叉树位置相同，可以在右下部分树不完美（缺失） 存储结构 顺序存储结构 链表存储 重要性质 一个二叉树第 i 层的最大结点数为：2**i-1 ，i&gt;=1 深度为k的二叉树有最大结点总数为： 2**k -1，k&gt;=1 对任何非空二叉树 T，若n₀表示叶结点的个数、n₂是 度为2的非叶结点个数，那么两者满足关系n₀ = n₂ +1(从上到下看和从下往上看得出的等式) 遍历顺序遍历 前序遍历 中序遍历 后序遍历 队列遍历 层次遍历 操作集 判断是非为空 遍历 创建而阐述","link":"/2022/07/07/%E6%A0%91/"},{"title":"待实现","text":"树递归遍历 先序遍历12345678void PreOrderTraversal(BinTree BT){ if(BT){ printf(&quot;%d&quot;, BT -&gt; Data); PreOrderTraveral(BT -&gt; Left); PreOrderTraveral(Bt -&gt; Right); }} 中序遍历12345678void InOrderTraversal(BinTree BT){ if(BT){ InOrderTraversal(BT -&gt; Left); printf(&quot;%d&quot;, BT -&gt; Data); InOrderTraversal(BT -&gt; Right); }} 后序遍历12345678void PostOrderTraversal(BinTree BT){ if(BT){ InOrderTraversal(BT -&gt; Left); InOrderTraversal(BT -&gt; Right); printf(&quot;%d&quot;, BT -&gt; Data); }} 非递归遍历 先序遍历1234567891011121314151617void InOrderTraversal(BinTree BT){ BinTree T, BT; Stack S = CreatStack(MaxSize); /*创建并初始化堆栈S*/ while(T || !IsEmpty(S)){ while(T){ /*一直向左并将沿途结点压入堆栈*/ Push(S,T); T = T -&gt; Left; } if(!IsEmpty(S)){ T = Pop(S); printf(&quot;%5d&quot;, T -&gt; Data); T = T -&gt; Right; } }} 中序遍历 后序遍历","link":"/2022/07/07/%E5%BE%85%E5%AE%9E%E7%8E%B0/"},{"title":"瑄瑄你好！","text":"嗨工作辛苦啦周末赶紧一起出去吃好吃的 2022-07-07 名词解释甘特图 Gantt chart又称为横道图、条状图(Bar chart)。其通过条状图来显示项目、进度和其他时间相关的系统进展的内在关系随着时间进展的情况。以提出者亨利·劳伦斯·甘特（Henry Laurence Gantt）先生的名字命名。","link":"/2022/07/06/%E7%91%84%E7%91%84%E4%BD%A0%E5%A5%BD/"}],"tags":[{"name":"Studying","slug":"Studying","link":"/tags/Studying/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"练习","slug":"练习","link":"/tags/%E7%BB%83%E4%B9%A0/"}],"categories":[]}